02/05/2012

Wow, first of May already! Okay so today I'm going to write for 10 minutes about the plans for my thesis. I'm going to start with an introduction on explanation - i.e. explain the background and motivation. I'll start with the first paragraph of the intro, something like the typical "OWL ontologies are blah", they are used in xyz, and all that. Then I'll continue with a very short overview of the OWL engineering process, where explanation/debugging comes into play. I'll mention justifications and cite loads of papers. Then I'll explain what kind of research has been done on justifications (mainly computation), but also that there has been a movement to make justifications more understandable (e.g. Matthew's laconic/precise, understanding justifications,root/derived, Ntuyen, the complexity study, etc.)

This is the point where I'll do the 'BUT LOOK, there are multiple justifications' thing and give a good example of multiple justifications for a single entailment. I might also mention multiple entailments here already (not sure how to introduce the issue of multiple justifications for multiple entailments without conflating stuff?). This motivates the "what are we going to do about multiple justifications" bit, where I explain the purpose of my research.

What IS the purpose of my research? What are the goals? The goal is to analyse the occurrence and frequency of multiple justifications in ontologies, to analyse whether they actually cause a problem (I haven't done any practical studies, but I guess we can just argue that looking at them in a list from top to bottom and repairing them individually almost always leads to non-optimal results). Once we have found that there are indeed multiple justifications and that the do cause problems, we have a motivation to find the solution for this issue. This is where we motivate several solutions. The ultimate goal is to reduce user effort when users are confronted with multiple justifications for a single or for a set of entailments. What is "reduce user effort"? 1) less time to reach the aim of removing the unwanted entailment, 2) less errors when removing the unwanted entailment. Less errors = less *wanted* information gets lost - i.e. similar to what Bernardo said in the paper (actually exactly the same. Although I'd argue that we're focusing on C-, i.e. removing entailments, and *preserving* the existing ones, rather than *adding* new ones in C+. Although I need to check again whether C+ includes the current entailments of O, I would think so...)
Right, so once we have a clear definition of the goals (less time, less errors) we also have something measurable.

This could be used in the evaluation, just as in Bijan/Aditya's www (I believe, or JWS) paper. 
We have to then find a motivation for the similarities and the structure. It's possible to say "well, considering justifications in isolation is obviously not great. We want to consider the set of justifications for an entailment as an *entity*, i.e. have a pair (Justs, eta), which is characteristic for the ontology and the entailment. Now, we want to take advantage of some of the properties of the set Justs, which allows us to reduce user effort when we're trying to get rid of eta.
This leads pretty quickly into 2 things: a) structural relations between the justifications in Justs (--> repair) and b) similarity (equivalence) relations that aid understanding. I think that's the two points covered!

So the goal is to take advantage of a) and b) in order to reduce user effort.

What's the final outcome, i.e. in which sense are we going to take advantage of these two? Currently, I've got grouping and ordering, and the JGraphs - I need something more concrete as the outcome's

* What am I going to do about preserving entailments, i.e. the repair bit? 